use std::io::{self};

fn main() {
    // string type
    // 문자열 리터럴 은 immutable, 변경할 수 없음.
    // 사용자로 부터 문자열을 입력 받아야 하는 상황에서는
    // 문자열 리터럴을 사용할 수 없음으로.
    // 또다른 문자열 타입인
    // String 을 제공함.
    // String 타입은 .힙에 할당된 데이터를 다루므로,
    // 컴파일 타임에 크기를 알수 없는 텍스트도 정장할 수 있음.
    // String type은 from 함수와 문자열 리터럴을 이용해 생성가능함.
    let mut s = String::from("Hello");
    s.push_str(", World");

    println!("Please input your guess.");
    println!("\u{2766} Please input your guess.");

    let mut guess = String::new();
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let s1 = String::from("Hello");
    let s2 = s1; // 이동(move)됨, 얕은복사(shallow copy)가 아님. s2 만 유효함으로 s2만 메모리해제, 문제가 해결됨.
    let mut s3 = s2.clone(); // 복제됨, 깊은복사.
    s3.push_str(", World");

    println!("\u{2766} {} {}, s2 = {}, s3 = {}", s, guess, s2, s3);

    //--> 정수형.
    // 스택에 저장됨으로 없어지지 않음
    let x = 5;
    let y = x;
    println!("\u{2766} {} + {} = {}", x, y, x + y);

    // Copy 가 가능한 타입
    // 모든 정수형, bool, 모든 부동 소수점 타입, 문자타입, Copy 타입만으로 구성된 튜플

    // 소유권과 함수
    takes_ownership(s); // s의 값이 함수로 이동됨.
                        // ... 따라서 여기서는 더 이상 유효하지 않음.
    makes_copy(x); // x 가 함수로 이동되지만
                   // i32 는 Copy 이므로 계속 x를 사용할 수 있음.
                   // 소유권 반환
    let g1 = gives_ownership();
    println!("\u{2766} {}", g1);
}

fn gives_ownership() -> String {
    let some_string = String::from("Yours");
    some_string
}
fn takes_ownership(some_string: String) {
    //
    println!("\u{2766} {}", some_string);
}

fn makes_copy(some_integer: i32) {
    //
    println!("\u{2766} {}", some_integer);
}
// 소유권
// -> 메모리 관리에 관한 규칙 모음.
// -> ownership

/*
--> ownership
- 각 값은 소유자가 정해져 있음.
- 하나의 값은 소유자가 도시에 여럿 존재할 수 없음.
- 소유자가 스코프 밖으로 벗어날 때, 값은 버려 짐 (dropped)

- 문자열 리터럴은 컴파일 타임에 내용을 알 수 있으므로, 켁스트가 최종 실행 파일에 하드코딩 됨.(문자열이 변하지 않을 때만 유효함.)
- 실행 중 크기가 변할 수도 있는 텍스트는 바이너리 파일에 집어 넣을 수 없음.

- 반면, String 타입은 힙에 메모리를 할당한느 방식을 사용하기 때문에 텍스트 내용 및 크기를 변경할 수 있음.
    - 실행 중 메모리 할당자로 부터 메모리를 요청해야 함.
    - String 사용을 마쳤을 때 메모리를 해제할 (즉, 할당자에게 메모리를 반납할) 방법이 필요함.

- 이 문제를 변수가 자신이 소속된 스코프를 벗어나는 순간 자동으로 메모리를 해제하는 방식으로 해결함.

{
    let s = String::from("hello"); // s는 이 지점부터 유효함.
    // s를 가지고 무언가 함.
}                                  // 이 스코프가 종료되었고, s는 더 이상
                                   // 유효하지 않음.


- 러스트는 변수가 스코프 밖으로 벗어나면, drop 이라는 특별한 함수를 호출함.

let x = 5; // 5를 x 에 바인딩하고,
let y = x; // x 값의 복사본을 만들어 y 에 바인딩 하시오.

--> (1) let s1 = String::from("Hello");
--> (2) let s2 = s1;

- `s1` 과 `s2` 가 동일 데이터를 가르킴
- 스코프를 벗어 나면서 drop 함수가 호출되면, 문제가 발생함.
- 동일한 pointer 를 각각 메모리를 해제하게 되면, 중복 해제ㅕdouble free) 오류발생, 이는 메모리 안정성 버그 중하나이며, 보안을 취약하게 만드는 메모리 손상의 원인.
--> (3) 메모리 안정성 보장을 위하여, let s2 = s1; 라인 뒤로는 s1 이 더 이상 유효하지 않다고 판단함으로 s1이 스코프를 벗어나더라도 아무것도 해제할 필요학 없어짐.
이름      값       인덱스      값
포인터    ------->  0         h
길이     5         1         e
용량     5         2         l
                  3         l
                  4         o

- 길이 : 현재 사용하고 있는 메모리를 바이트 단위로 나타낸 것
- 용량 : 메모리 할당자가 String 에 할당한 메모리의 양을 뜻함.


--> stack
스택에 저장되는 데이터는 모두 명확학 크기가 정해져 있어야 함.
컴파일 타임에 크기를 알 수 없거나, 크기가 변경될 수 있는 데이터는 스택 대신 힙에 저장.
함수를 호출 하면, 호출한 함수에 넘겨준 값(포인터도 있을 수 있음.)
함수가 종료되면 팝됨.

--> heap
데이터를 힙에 넣을 때 먼저 저장할 공간이 있는지 운영체제에게 물어봄.
그러면, 메모리 할당자는 커다란 힙 영역 안데엇 어떤 빈 지점을 찾고, 이 지점은 사용 중이라고 표시한 뒤 해당 지점을 가리키는 포인터(pointer) 를 우리한테 반환함.
이 과정을 힙 공간 할당 (allocating on the heap), 줄여서 할당(allocation) 이라 함.
- 스택에 값을 푸시하는 것은 할당이라 부르지 않음.
- 포인터는 크기가 정해져 있어 스택에 저장할 수 있으나
- 포인터가 가리키는 실제 데이터를 사용하고자 할 때는 포인터를 참조해 해당 포인터가 가르키는 위치로 이동하는 과정을 거침.
- 레스토랑에 자리에 앉는 과정으로 비교.
1. 레스토랑에 입장하면, 직원에게 인원수를 알림.
2. 직원은 인원수에 맞는 빈 테이블을 찾아 안내.
3. 이후에 온 일행이 우리 테이블을 찾을 땐 직원에게 물어 안내를 받음.


*/
